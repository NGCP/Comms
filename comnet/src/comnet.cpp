/* This file was autogenerated. All changes will be undone. */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include <comnet.h>
#include <comnet_parser.h>
#include <comnet_message.h>
#include <datalink.h>
#include <serial.h>
#include <udp.h>
#include <pqueue.h>
#include <threadCom.h>
#include <zigBee.h>

#include <fstream>
#include <string>

using namespace comnet;

node::node(uint8_t node_id)
{ 
	memset(datalinks,0,sizeof(datalinks));
	num_datalinks = 0;

	null_callback_storage();

	/* destroy pointer and node in the event of invalid id */
	if(node_id == 0)
	{
		this->~node();
		return;
	}
	this->node_id = node_id;
    
    /* Load aes 128 bit key from file and store in private member variable*/
	readKey();

	thread_create(&handler_thread, &node::handler_helper, this);
	
}

/* Create a node with a specified mode, TBD */
node::node(uint8_t node_id, int32_t mode)
{ 
	memset(datalinks,0,sizeof(datalinks));
	num_datalinks = 0;

	null_callback_storage();

	if(node_id == 0)
	{
		this->~node();
		return;
	}
	this->node_id = node_id;
    
    /* Load aes 128 bit key from file and store in private member variable*/
	readKey(); //change

	thread_create(&handler_thread, &node::handler_helper, this);
	
}
node::~node()
{
	int32_t i;
	for(i = 0; i<num_datalinks; i++)
	{
		datalinks[i]->close();
	}

}

/* Need to call start to create the comnet handler, usually after establish functions */
void node::start()
{
	try
	{
		//thread_create(&upkeep_thread, &node::upkeep_helper, this);
	}
	catch(int e)
	{
		printf("thread_create out: %d\n", e);
	
	}
}

/* Read key from text file*/
void node::readKey()
{
/* C# cannot import fstream for some reason*/ 
#ifdef _MANAGED
	String^ fileName = "key.txt";
	String^ str;
	try
	{
		StreamReader^ din = File::OpenText(fileName);
		str = din->ReadLine();
		if (str->Length - 1 >= AES::DEFAULT_KEYLENGTH)
		{
			IntPtr^ ip = Marshal::StringToHGlobalAnsi(str);
			if (ip != IntPtr::Zero)
			{
				const char *keyCast = reinterpret_cast<const char *>(ip->ToPointer());

				for (int x = 0; x < AES::DEFAULT_KEYLENGTH; x++)
				{
					key[x] = keyCast[x];
				}
			}
		}

	}
	catch (Exception^ e)
	{
		if (dynamic_cast<FileNotFoundException^>(e))
			Console::WriteLine("file '{0}' not found", fileName);
		else
			Console::WriteLine("problem reading file '{0}'", fileName);
	}



#else
	/**Load encryption key 128bits*/
	std::ifstream keyFileInput("key.txt");
	std::string inputString;	
	if (keyFileInput.is_open())
	{
		std::getline(keyFileInput, inputString);

		if (inputString.length() >= AES::DEFAULT_KEYLENGTH)
		{
			for (int x = 0; x < AES::DEFAULT_KEYLENGTH; x++)
			{
				key[x] = inputString[x];
			}
		}
		else
		{
			printf("key.txt characters mismatch.\nCharacters found: %d\nCharacters needed: %d\n", inputString.length(), AES::DEFAULT_KEYLENGTH);
		}
	}
	else//file not open
	{
		printf("key.txt not found. \n");
	}
	keyFileInput.close();
#endif

}


/* Entry point for the event handler that performs callbacks based on incoming messages */
void* node::comnet_handler()
{
	com_msg_t com_msg;	
	while(1)
	{
		/* Blocking call to the message queue, unblock when messages are in queue */
		queue.remove(&com_msg);
		{
			{				
				/* Behavior on an outgoing message from client*/
				if(com_msg.direction == Com_Out)
				{
//#ifdef DEBUG
					printf("Node %d Outbound: Source id: %d, Dest. id %d, Message type: %s\n", this->node_id,com_msg.header.node_src_id, com_msg.header.node_dest_id, com_typestr((com_msg_type_t)com_msg.header.message_type));
//#endif
					int32_t i;
					if(num_datalinks>0)
					{
						for(i = 0;i<num_datalinks;i++)
						{
							datalinks[i]->send(com_msg.header.node_dest_id, com_msg.data, com_msg.tx_len);
						}
					}
				}
				/* Behavior on an incoming message from client*/
				else if(com_msg.direction == Com_In)				
				{
//#ifdef DEBUG
					printf("Node %d Inbound: Source id: %d, Dest. id %d, Message type: %s\n", this->node_id,com_msg.header.node_src_id, com_msg.header.node_dest_id, com_typestr((com_msg_type_t)com_msg.header.message_type));
//#endif
					if((com_msg.header.node_dest_id == this->node_id) || (com_msg.header.node_dest_id == 0))
					{

						com_msg_buf_t rx_buf;
						/* Unpack and identify the type of incoming message */
						unpack_com_msg_t(&com_msg, &rx_buf);
                        
                        /** Decrypt */	
                        /* Managed C (CLR) will freak out if you pass SecByteBlock as an argument this is my half ass fix MW*/
                        CryptoPP::SecByteBlock secKey(key, AES::DEFAULT_KEYLENGTH);                      
						CFB_Mode<AES>::Decryption cfbDecryption(secKey, secKey.size(), com_msg.header.iv);
						cfbDecryption.ProcessData((byte*)com_msg.data, (byte*)com_msg.data, com_msg.header.message_length);
                        
						/* Perform a callback based on message type */
						handle_com_msg_t(&com_msg, &rx_buf);
					}
				}
			}
		}
	}
	return 0;
}

void* node::upkeep_handler()
{
	while(1)
	{
		//this->send_enter();
#ifdef _WIN32
		_sleep(5000);
#endif
#ifndef _WIN32
		sleep(5000);
#endif
	}
	return 0;
}

void node::add_serial(int8_t* link_id, uint32_t baud_rate, char device_path[50])
{
	/* Initialize a datalink pointer as a Serial link */
	datalinks[num_datalinks] = new Serial();

	/* Cast the datalink as a Serial datalink and open it with required options */
	if(((Serial*)(datalinks[num_datalinks]))->open(baud_rate, device_path) == 0)
	{
		/* Provide a reference to the queue for access to comnet handler, runs the datalink */
		datalinks[num_datalinks]->set_link_id(num_datalinks);
		datalinks[num_datalinks]->set_queue(&this->queue);
		datalinks[num_datalinks]->run();

		/* Provide the link_id for future reference, simply increment to keep track */
		*link_id = num_datalinks;
		num_datalinks++;
	}
}


void node::add_udp(int8_t* link_id, uint16_t port)
{
	/* Follows the same format as the above function, except UDP oriented */
	datalinks[num_datalinks] = new UDP(port);
	if(datalinks[num_datalinks]->is_connected())
	{
		datalinks[num_datalinks]->set_link_id(num_datalinks);
		datalinks[num_datalinks]->set_queue(&this->queue);
		datalinks[num_datalinks]->run();
		*link_id = num_datalinks;
		num_datalinks++;
	}
}
	
void node::add_udp(int8_t* link_id, uint16_t port, char addr[16])
{
	/* 
	Follows the same format as the above function, 
	except targets an interface specified by IP
	*/
	datalinks[num_datalinks] = new UDP(port, addr);
	if(datalinks[num_datalinks]->is_connected())
	{
		datalinks[num_datalinks]->set_link_id(num_datalinks);
		datalinks[num_datalinks]->set_queue(&this->queue);
		datalinks[num_datalinks]->run();
		*link_id = num_datalinks;
		num_datalinks++;
	}
}

void node::add_zigBee(int8_t* link_id, uint32_t baudRate, char device_path[50])
{
	datalinks[num_datalinks] = new ZigBee(baudRate, device_path);

	if (datalinks[num_datalinks]->is_connected())
	{
		datalinks[num_datalinks]->set_link_id(num_datalinks);
		datalinks[num_datalinks]->set_queue(&this->queue);
		datalinks[num_datalinks]->run();//doesnt do any thing
		*link_id = num_datalinks;
		num_datalinks++;
	}
}

void node::establish_zigBee(int8_t link_id, uint8_t node_id, std::string address64Hex)
{
	if (datalinks[link_id]->get_datalink_type() == ZIGBEE_TYPE && datalinks[link_id]->is_connected())
	{
		((ZigBee*)datalinks[link_id])->establish(node_id, address64Hex);
	}
}

void node::establish_serial(int8_t link_id, uint8_t node_id)
{
	/* 
	Check that the datalink is of the correct type & connected, 
	and set the node_id 
	*/
	if(datalinks[link_id]->get_datalink_type() == SERIAL_TYPE && datalinks[link_id]->is_connected())
	{
		datalinks[link_id]->establish(node_id);
	}
	
}
void node::establish_udp(int8_t link_id, uint8_t node_id, uint16_t port, char addr[16])
{
	/* This is similar to the Serial establish function, except for UDP */
	if(datalinks[link_id]->get_datalink_type()== UDP_TYPE && datalinks[link_id]->is_connected())
	{
		((UDP*)datalinks[link_id])->establish(node_id, port, addr);
	}
}

uint8_t node::get_num_datalinks()
{
	return(this->num_datalinks);
}

int32_t node::query_datalink_connected(int8_t link_id)
{
	/* Returns 1 if the datalink is connected */
	return(datalinks[link_id]->is_connected());
}

datalink_type_t node::query_datalink_type(int8_t link_id)
{
	return(datalinks[link_id]->get_datalink_type());
}

/* Helper functions from C style from C++ entry point with class member linkage */
void* node::handler_helper(void* context)
{
	return ((node*)context)->comnet_handler();
}

void* node::upkeep_helper(void* context)
{
	return ((node*)context)->upkeep_handler();
}

void node::null_callback_storage()
{
   on_enter = NULL;
   on_ping = NULL;
   on_pong = NULL;
   on_exit = NULL;
   on_raw_data = NULL;
   on_connection_request = NULL;
   on_connection_reply = NULL;
   on_vehicle_identification = NULL;
   on_vehicle_authorization_request = NULL;
   on_vehicle_authorization_reply = NULL;
   on_vehicle_mode_command = NULL;
   on_vehicle_joystick_command = NULL;
   on_vehicle_termination_command = NULL;
   on_vehicle_telemetry_command = NULL;
   on_vehicle_system_status = NULL;
   on_vehicle_inertial_state = NULL;
   on_vehicle_global_position = NULL;
   on_vehicle_body_sensed_state = NULL;
   on_vehicle_attitude = NULL;
   on_air_vehicle_ground_relative_state = NULL;
   on_payload_bay_command = NULL;
   on_payload_data_recorder_command = NULL;
   on_payload_operation_command = NULL;
   on_communications_payload_command = NULL;
   on_communications_payload_configuration_command = NULL;
   on_payload_bay_mode_command = NULL;
   on_payload_bay_status = NULL;
   on_payload_data_recorder_status = NULL;
   on_payload_operating_status = NULL;
   on_communications_payload_status = NULL;
   on_target_status = NULL;
   on_target_acknowledgement = NULL;
   on_UAV_location = NULL;
   on_UAV_speed = NULL;
   on_UAV_heading = NULL;
   on_UAV_battery = NULL;
   on_UAV_collision_avodiance_status = NULL;
   on_UAV_mission_status = NULL;
   on_UAV_collision_avodiance_message = NULL;
   on_UUV_status = NULL;
   on_ROV_status_message = NULL;
}
void node::handle_com_msg_t(com_msg_t* rx_msg, com_msg_buf_t* rx_buf)
{
   switch(rx_msg->header.message_type)
   {
   case Com_Enter:
      {
         if(on_enter == NULL)
         {
         }
         else
         {
            this->on_enter(rx_msg->link_id, rx_msg->header, rx_buf->enter, this);
         }
         break;
      }
   case Com_Ping:
      {
         if(on_ping == NULL)
         {
         }
         else
         {
            this->on_ping(rx_msg->link_id, rx_msg->header, rx_buf->ping, this);
         }
         break;
      }
   case Com_Pong:
      {
         if(on_pong == NULL)
         {
         }
         else
         {
            this->on_pong(rx_msg->link_id, rx_msg->header, rx_buf->pong, this);
         }
         break;
      }
   case Com_Exit:
      {
         if(on_exit == NULL)
         {
         }
         else
         {
            this->on_exit(rx_msg->link_id, rx_msg->header, rx_buf->exit, this);
         }
         break;
      }
   case Com_Raw_Data:
      {
         if(on_raw_data == NULL)
         {
         }
         else
         {
            this->on_raw_data(rx_msg->link_id, rx_msg->header, rx_buf->raw_data, this);
         }
         break;
      }
   case Com_Connection_Request:
      {
         if(on_connection_request == NULL)
         {
         }
         else
         {
            this->on_connection_request(rx_msg->link_id, rx_msg->header, rx_buf->connection_request, this);
         }
         break;
      }
   case Com_Connection_Reply:
      {
         if(on_connection_reply == NULL)
         {
         }
         else
         {
            this->on_connection_reply(rx_msg->link_id, rx_msg->header, rx_buf->connection_reply, this);
         }
         break;
      }
   case Com_Vehicle_Identification:
      {
         if(on_vehicle_identification == NULL)
         {
         }
         else
         {
            this->on_vehicle_identification(rx_msg->link_id, rx_msg->header, rx_buf->vehicle_identification, this);
         }
         break;
      }
   case Com_Vehicle_Authorization_Request:
      {
         if(on_vehicle_authorization_request == NULL)
         {
         }
         else
         {
            this->on_vehicle_authorization_request(rx_msg->link_id, rx_msg->header, rx_buf->vehicle_authorization_request, this);
         }
         break;
      }
   case Com_Vehicle_Authorization_Reply:
      {
         if(on_vehicle_authorization_reply == NULL)
         {
         }
         else
         {
            this->on_vehicle_authorization_reply(rx_msg->link_id, rx_msg->header, rx_buf->vehicle_authorization_reply, this);
         }
         break;
      }
   case Com_Vehicle_Mode_Command:
      {
         if(on_vehicle_mode_command == NULL)
         {
         }
         else
         {
            this->on_vehicle_mode_command(rx_msg->link_id, rx_msg->header, rx_buf->vehicle_mode_command, this);
         }
         break;
      }
   case Com_Vehicle_Joystick_Command:
      {
         if(on_vehicle_joystick_command == NULL)
         {
         }
         else
         {
            this->on_vehicle_joystick_command(rx_msg->link_id, rx_msg->header, rx_buf->vehicle_joystick_command, this);
         }
         break;
      }
   case Com_Vehicle_Termination_Command:
      {
         if(on_vehicle_termination_command == NULL)
         {
         }
         else
         {
            this->on_vehicle_termination_command(rx_msg->link_id, rx_msg->header, rx_buf->vehicle_termination_command, this);
         }
         break;
      }
   case Com_Vehicle_Telemetry_Command:
      {
         if(on_vehicle_telemetry_command == NULL)
         {
         }
         else
         {
            this->on_vehicle_telemetry_command(rx_msg->link_id, rx_msg->header, rx_buf->vehicle_telemetry_command, this);
         }
         break;
      }
   case Com_Vehicle_System_Status:
      {
         if(on_vehicle_system_status == NULL)
         {
         }
         else
         {
            this->on_vehicle_system_status(rx_msg->link_id, rx_msg->header, rx_buf->vehicle_system_status, this);
         }
         break;
      }
   case Com_Vehicle_Inertial_State:
      {
         if(on_vehicle_inertial_state == NULL)
         {
         }
         else
         {
            this->on_vehicle_inertial_state(rx_msg->link_id, rx_msg->header, rx_buf->vehicle_inertial_state, this);
         }
         break;
      }
   case Com_Vehicle_Global_Position:
      {
         if(on_vehicle_global_position == NULL)
         {
         }
         else
         {
            this->on_vehicle_global_position(rx_msg->link_id, rx_msg->header, rx_buf->vehicle_global_position, this);
         }
         break;
      }
   case Com_Vehicle_Body_Sensed_State:
      {
         if(on_vehicle_body_sensed_state == NULL)
         {
         }
         else
         {
            this->on_vehicle_body_sensed_state(rx_msg->link_id, rx_msg->header, rx_buf->vehicle_body_sensed_state, this);
         }
         break;
      }
   case Com_Vehicle_Attitude:
      {
         if(on_vehicle_attitude == NULL)
         {
         }
         else
         {
            this->on_vehicle_attitude(rx_msg->link_id, rx_msg->header, rx_buf->vehicle_attitude, this);
         }
         break;
      }
   case Com_Air_Vehicle_Ground_Relative_State:
      {
         if(on_air_vehicle_ground_relative_state == NULL)
         {
         }
         else
         {
            this->on_air_vehicle_ground_relative_state(rx_msg->link_id, rx_msg->header, rx_buf->air_vehicle_ground_relative_state, this);
         }
         break;
      }
   case Com_Payload_Bay_Command:
      {
         if(on_payload_bay_command == NULL)
         {
         }
         else
         {
            this->on_payload_bay_command(rx_msg->link_id, rx_msg->header, rx_buf->payload_bay_command, this);
         }
         break;
      }
   case Com_Payload_Data_Recorder_Command:
      {
         if(on_payload_data_recorder_command == NULL)
         {
         }
         else
         {
            this->on_payload_data_recorder_command(rx_msg->link_id, rx_msg->header, rx_buf->payload_data_recorder_command, this);
         }
         break;
      }
   case Com_Payload_Operation_Command:
      {
         if(on_payload_operation_command == NULL)
         {
         }
         else
         {
            this->on_payload_operation_command(rx_msg->link_id, rx_msg->header, rx_buf->payload_operation_command, this);
         }
         break;
      }
   case Com_Communications_Payload_Command:
      {
         if(on_communications_payload_command == NULL)
         {
         }
         else
         {
            this->on_communications_payload_command(rx_msg->link_id, rx_msg->header, rx_buf->communications_payload_command, this);
         }
         break;
      }
   case Com_Communications_Payload_Configuration_Command:
      {
         if(on_communications_payload_configuration_command == NULL)
         {
         }
         else
         {
            this->on_communications_payload_configuration_command(rx_msg->link_id, rx_msg->header, rx_buf->communications_payload_configuration_command, this);
         }
         break;
      }
   case Com_Payload_Bay_Mode_Command:
      {
         if(on_payload_bay_mode_command == NULL)
         {
         }
         else
         {
            this->on_payload_bay_mode_command(rx_msg->link_id, rx_msg->header, rx_buf->payload_bay_mode_command, this);
         }
         break;
      }
   case Com_Payload_Bay_Status:
      {
         if(on_payload_bay_status == NULL)
         {
         }
         else
         {
            this->on_payload_bay_status(rx_msg->link_id, rx_msg->header, rx_buf->payload_bay_status, this);
         }
         break;
      }
   case Com_Payload_Data_Recorder_Status:
      {
         if(on_payload_data_recorder_status == NULL)
         {
         }
         else
         {
            this->on_payload_data_recorder_status(rx_msg->link_id, rx_msg->header, rx_buf->payload_data_recorder_status, this);
         }
         break;
      }
   case Com_Payload_Operating_Status:
      {
         if(on_payload_operating_status == NULL)
         {
         }
         else
         {
            this->on_payload_operating_status(rx_msg->link_id, rx_msg->header, rx_buf->payload_operating_status, this);
         }
         break;
      }
   case Com_Communications_Payload_Status:
      {
         if(on_communications_payload_status == NULL)
         {
         }
         else
         {
            this->on_communications_payload_status(rx_msg->link_id, rx_msg->header, rx_buf->communications_payload_status, this);
         }
         break;
      }
   case Com_Target_Status:
      {
         if(on_target_status == NULL)
         {
         }
         else
         {
            this->on_target_status(rx_msg->link_id, rx_msg->header, rx_buf->target_status, this);
         }
         break;
      }
   case Com_Target_Acknowledgement:
      {
         if(on_target_acknowledgement == NULL)
         {
         }
         else
         {
            this->on_target_acknowledgement(rx_msg->link_id, rx_msg->header, rx_buf->target_acknowledgement, this);
         }
         break;
      }
   case Com_UAV_Location:
      {
         if(on_UAV_location == NULL)
         {
         }
         else
         {
            this->on_UAV_location(rx_msg->link_id, rx_msg->header, rx_buf->UAV_location, this);
         }
         break;
      }
   case Com_UAV_Speed:
      {
         if(on_UAV_speed == NULL)
         {
         }
         else
         {
            this->on_UAV_speed(rx_msg->link_id, rx_msg->header, rx_buf->UAV_speed, this);
         }
         break;
      }
   case Com_UAV_Heading:
      {
         if(on_UAV_heading == NULL)
         {
         }
         else
         {
            this->on_UAV_heading(rx_msg->link_id, rx_msg->header, rx_buf->UAV_heading, this);
         }
         break;
      }
   case Com_UAV_Battery:
      {
         if(on_UAV_battery == NULL)
         {
         }
         else
         {
            this->on_UAV_battery(rx_msg->link_id, rx_msg->header, rx_buf->UAV_battery, this);
         }
         break;
      }
   case Com_UAV_Collision_Avodiance_Status:
      {
         if(on_UAV_collision_avodiance_status == NULL)
         {
         }
         else
         {
            this->on_UAV_collision_avodiance_status(rx_msg->link_id, rx_msg->header, rx_buf->UAV_collision_avodiance_status, this);
         }
         break;
      }
   case Com_UAV_Mission_Status:
      {
         if(on_UAV_mission_status == NULL)
         {
         }
         else
         {
            this->on_UAV_mission_status(rx_msg->link_id, rx_msg->header, rx_buf->UAV_mission_status, this);
         }
         break;
      }
   case Com_UAV_Collision_Avodiance_Message:
      {
         if(on_UAV_collision_avodiance_message == NULL)
         {
         }
         else
         {
            this->on_UAV_collision_avodiance_message(rx_msg->link_id, rx_msg->header, rx_buf->UAV_collision_avodiance_message, this);
         }
         break;
      }
   case Com_UUV_Status:
      {
         if(on_UUV_status == NULL)
         {
         }
         else
         {
            this->on_UUV_status(rx_msg->link_id, rx_msg->header, rx_buf->UUV_status, this);
         }
         break;
      }
   case Com_ROV_Status_Message:
      {
         if(on_ROV_status_message == NULL)
         {
         }
         else
         {
            this->on_ROV_status_message(rx_msg->link_id, rx_msg->header, rx_buf->ROV_status_message, this);
         }
         break;
      }
   }
}

void node::send_enter(
   uint8_t dest_id,
   float64_t timestamp,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   enter_t enter;
   enter.timestamp = timestamp;
   encode_enter(this->node_id, dest_id, &enter, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_ping(
   uint8_t dest_id,
   float64_t timestamp,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   ping_t ping;
   ping.timestamp = timestamp;
   encode_ping(this->node_id, dest_id, &ping, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_pong(
   uint8_t dest_id,
   float64_t timestamp,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   pong_t pong;
   pong.timestamp = timestamp;
   encode_pong(this->node_id, dest_id, &pong, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_exit(
   uint8_t dest_id,
   float64_t timestamp,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   exit_t exit;
   exit.timestamp = timestamp;
   encode_exit(this->node_id, dest_id, &exit, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_raw_data(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t length,
   uint8_t data,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   raw_data_t raw_data;
   raw_data.timestamp = timestamp;
   raw_data.length = length;
   raw_data.data = data;
   encode_raw_data(this->node_id, dest_id, &raw_data, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_connection_request(
   uint8_t dest_id,
   float64_t timestamp,
   uint8_t trace_node_1,
   uint8_t trace_node_n,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   connection_request_t connection_request;
   connection_request.timestamp = timestamp;
   connection_request.trace_node_1 = trace_node_1;
   connection_request.trace_node_n = trace_node_n;
   encode_connection_request(this->node_id, dest_id, &connection_request, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_connection_reply(
   uint8_t dest_id,
   float64_t timestamp,
   uint8_t connection_ID,
   uint8_t trace_node_n,
   uint8_t trace_node_n_1,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   connection_reply_t connection_reply;
   connection_reply.timestamp = timestamp;
   connection_reply.connection_ID = connection_ID;
   connection_reply.trace_node_n = trace_node_n;
   connection_reply.trace_node_n_1 = trace_node_n_1;
   encode_connection_reply(this->node_id, dest_id, &connection_reply, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_vehicle_identification(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t vehicle_ID,
   uint8_t vehicle_type,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   vehicle_identification_t vehicle_identification;
   vehicle_identification.timestamp = timestamp;
   vehicle_identification.vehicle_ID = vehicle_ID;
   vehicle_identification.vehicle_type = vehicle_type;
   encode_vehicle_identification(this->node_id, dest_id, &vehicle_identification, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_vehicle_authorization_request(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t vehicle_ID,
   uint8_t vehicle_type,
   uint8_t authorized_services,
   uint8_t granted_services,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   vehicle_authorization_request_t vehicle_authorization_request;
   vehicle_authorization_request.timestamp = timestamp;
   vehicle_authorization_request.vehicle_ID = vehicle_ID;
   vehicle_authorization_request.vehicle_type = vehicle_type;
   vehicle_authorization_request.authorized_services = authorized_services;
   vehicle_authorization_request.granted_services = granted_services;
   encode_vehicle_authorization_request(this->node_id, dest_id, &vehicle_authorization_request, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_vehicle_authorization_reply(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t vehicle_ID,
   uint8_t vehicle_type,
   uint8_t authorized_services,
   uint8_t granted_services,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   vehicle_authorization_reply_t vehicle_authorization_reply;
   vehicle_authorization_reply.timestamp = timestamp;
   vehicle_authorization_reply.vehicle_ID = vehicle_ID;
   vehicle_authorization_reply.vehicle_type = vehicle_type;
   vehicle_authorization_reply.authorized_services = authorized_services;
   vehicle_authorization_reply.granted_services = granted_services;
   encode_vehicle_authorization_reply(this->node_id, dest_id, &vehicle_authorization_reply, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_vehicle_mode_command(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t vehicle_ID,
   uint8_t vehicle_mode,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   vehicle_mode_command_t vehicle_mode_command;
   vehicle_mode_command.timestamp = timestamp;
   vehicle_mode_command.vehicle_ID = vehicle_ID;
   vehicle_mode_command.vehicle_mode = vehicle_mode;
   encode_vehicle_mode_command(this->node_id, dest_id, &vehicle_mode_command, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_vehicle_joystick_command(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t vehicle_ID,
   float32_t steering,
   float32_t throttle,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   vehicle_joystick_command_t vehicle_joystick_command;
   vehicle_joystick_command.timestamp = timestamp;
   vehicle_joystick_command.vehicle_ID = vehicle_ID;
   vehicle_joystick_command.steering = steering;
   vehicle_joystick_command.throttle = throttle;
   encode_vehicle_joystick_command(this->node_id, dest_id, &vehicle_joystick_command, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_vehicle_termination_command(
   uint8_t dest_id,
   uint64_t timestamp,
   uint16_t vehicle_ID,
   uint8_t termination_mode,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   vehicle_termination_command_t vehicle_termination_command;
   vehicle_termination_command.timestamp = timestamp;
   vehicle_termination_command.vehicle_ID = vehicle_ID;
   vehicle_termination_command.termination_mode = termination_mode;
   encode_vehicle_termination_command(this->node_id, dest_id, &vehicle_termination_command, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_vehicle_telemetry_command(
   uint8_t dest_id,
   uint64_t timestamp,
   uint16_t vehicle_ID,
   uint8_t telemetry_select,
   uint8_t telemetry_rate,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   vehicle_telemetry_command_t vehicle_telemetry_command;
   vehicle_telemetry_command.timestamp = timestamp;
   vehicle_telemetry_command.vehicle_ID = vehicle_ID;
   vehicle_telemetry_command.telemetry_select = telemetry_select;
   vehicle_telemetry_command.telemetry_rate = telemetry_rate;
   encode_vehicle_telemetry_command(this->node_id, dest_id, &vehicle_telemetry_command, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_vehicle_system_status(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t vehicle_ID,
   uint8_t vehicle_mode,
   uint8_t vehicle_state,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   vehicle_system_status_t vehicle_system_status;
   vehicle_system_status.timestamp = timestamp;
   vehicle_system_status.vehicle_ID = vehicle_ID;
   vehicle_system_status.vehicle_mode = vehicle_mode;
   vehicle_system_status.vehicle_state = vehicle_state;
   encode_vehicle_system_status(this->node_id, dest_id, &vehicle_system_status, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_vehicle_inertial_state(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t vehicle_ID,
   float64_t latitude,
   float64_t longitude,
   float32_t altitude,
   float32_t roll,
   float32_t pitch,
   float32_t heading,
   float32_t north_speed,
   float32_t east_speed,
   float32_t vertical_speed,
   float32_t roll_rate,
   float32_t pitch_rate,
   float32_t yaw_rate,
   float32_t north_accel,
   float32_t east_accel,
   float32_t vertical_accel,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   vehicle_inertial_state_t vehicle_inertial_state;
   vehicle_inertial_state.timestamp = timestamp;
   vehicle_inertial_state.vehicle_ID = vehicle_ID;
   vehicle_inertial_state.latitude = latitude;
   vehicle_inertial_state.longitude = longitude;
   vehicle_inertial_state.altitude = altitude;
   vehicle_inertial_state.roll = roll;
   vehicle_inertial_state.pitch = pitch;
   vehicle_inertial_state.heading = heading;
   vehicle_inertial_state.north_speed = north_speed;
   vehicle_inertial_state.east_speed = east_speed;
   vehicle_inertial_state.vertical_speed = vertical_speed;
   vehicle_inertial_state.roll_rate = roll_rate;
   vehicle_inertial_state.pitch_rate = pitch_rate;
   vehicle_inertial_state.yaw_rate = yaw_rate;
   vehicle_inertial_state.north_accel = north_accel;
   vehicle_inertial_state.east_accel = east_accel;
   vehicle_inertial_state.vertical_accel = vertical_accel;
   encode_vehicle_inertial_state(this->node_id, dest_id, &vehicle_inertial_state, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_vehicle_global_position(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t vehicle_ID,
   int32_t latitude,
   int32_t longitude,
   int32_t altitude,
   int16_t x_speed,
   int16_t y_speed,
   int16_t z_speed,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   vehicle_global_position_t vehicle_global_position;
   vehicle_global_position.timestamp = timestamp;
   vehicle_global_position.vehicle_ID = vehicle_ID;
   vehicle_global_position.latitude = latitude;
   vehicle_global_position.longitude = longitude;
   vehicle_global_position.altitude = altitude;
   vehicle_global_position.x_speed = x_speed;
   vehicle_global_position.y_speed = y_speed;
   vehicle_global_position.z_speed = z_speed;
   encode_vehicle_global_position(this->node_id, dest_id, &vehicle_global_position, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_vehicle_body_sensed_state(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t vehicle_ID,
   int16_t x_accel,
   int16_t y_accel,
   int16_t z_accel,
   int16_t roll_rate,
   int16_t pitch_rate,
   int16_t yaw_rate,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   vehicle_body_sensed_state_t vehicle_body_sensed_state;
   vehicle_body_sensed_state.timestamp = timestamp;
   vehicle_body_sensed_state.vehicle_ID = vehicle_ID;
   vehicle_body_sensed_state.x_accel = x_accel;
   vehicle_body_sensed_state.y_accel = y_accel;
   vehicle_body_sensed_state.z_accel = z_accel;
   vehicle_body_sensed_state.roll_rate = roll_rate;
   vehicle_body_sensed_state.pitch_rate = pitch_rate;
   vehicle_body_sensed_state.yaw_rate = yaw_rate;
   encode_vehicle_body_sensed_state(this->node_id, dest_id, &vehicle_body_sensed_state, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_vehicle_attitude(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t vehicle_ID,
   float32_t roll,
   float32_t pitch,
   float32_t yaw,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   vehicle_attitude_t vehicle_attitude;
   vehicle_attitude.timestamp = timestamp;
   vehicle_attitude.vehicle_ID = vehicle_ID;
   vehicle_attitude.roll = roll;
   vehicle_attitude.pitch = pitch;
   vehicle_attitude.yaw = yaw;
   encode_vehicle_attitude(this->node_id, dest_id, &vehicle_attitude, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_air_vehicle_ground_relative_state(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t vehicle_ID,
   float32_t angle_of_attack,
   float32_t angle_of_sideslip,
   float32_t true_airspeed,
   float32_t indicated_airspeed,
   float32_t north_wind_speed,
   float32_t east_wind_speed,
   float32_t north_ground_speed,
   float32_t east_ground_speed,
   float32_t barometric_pressure,
   float32_t barometric_altitude,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   air_vehicle_ground_relative_state_t air_vehicle_ground_relative_state;
   air_vehicle_ground_relative_state.timestamp = timestamp;
   air_vehicle_ground_relative_state.vehicle_ID = vehicle_ID;
   air_vehicle_ground_relative_state.angle_of_attack = angle_of_attack;
   air_vehicle_ground_relative_state.angle_of_sideslip = angle_of_sideslip;
   air_vehicle_ground_relative_state.true_airspeed = true_airspeed;
   air_vehicle_ground_relative_state.indicated_airspeed = indicated_airspeed;
   air_vehicle_ground_relative_state.north_wind_speed = north_wind_speed;
   air_vehicle_ground_relative_state.east_wind_speed = east_wind_speed;
   air_vehicle_ground_relative_state.north_ground_speed = north_ground_speed;
   air_vehicle_ground_relative_state.east_ground_speed = east_ground_speed;
   air_vehicle_ground_relative_state.barometric_pressure = barometric_pressure;
   air_vehicle_ground_relative_state.barometric_altitude = barometric_altitude;
   encode_air_vehicle_ground_relative_state(this->node_id, dest_id, &air_vehicle_ground_relative_state, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_payload_bay_command(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t payload_bay_ID,
   uint8_t payload_command,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   payload_bay_command_t payload_bay_command;
   payload_bay_command.timestamp = timestamp;
   payload_bay_command.payload_bay_ID = payload_bay_ID;
   payload_bay_command.payload_command = payload_command;
   encode_payload_bay_command(this->node_id, dest_id, &payload_bay_command, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_payload_data_recorder_command(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t payload_ID,
   uint8_t payload_recorder_mode,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   payload_data_recorder_command_t payload_data_recorder_command;
   payload_data_recorder_command.timestamp = timestamp;
   payload_data_recorder_command.payload_ID = payload_ID;
   payload_data_recorder_command.payload_recorder_mode = payload_recorder_mode;
   encode_payload_data_recorder_command(this->node_id, dest_id, &payload_data_recorder_command, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_payload_operation_command(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t payload_ID,
   uint8_t payload_command,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   payload_operation_command_t payload_operation_command;
   payload_operation_command.timestamp = timestamp;
   payload_operation_command.payload_ID = payload_ID;
   payload_operation_command.payload_command = payload_command;
   encode_payload_operation_command(this->node_id, dest_id, &payload_operation_command, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_communications_payload_command(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t comms_payload_ID,
   uint8_t comms_payload_command,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   communications_payload_command_t communications_payload_command;
   communications_payload_command.timestamp = timestamp;
   communications_payload_command.comms_payload_ID = comms_payload_ID;
   communications_payload_command.comms_payload_command = comms_payload_command;
   encode_communications_payload_command(this->node_id, dest_id, &communications_payload_command, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_communications_payload_configuration_command(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t comms_payload_ID,
   uint8_t comms_payload_mode,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   communications_payload_configuration_command_t communications_payload_configuration_command;
   communications_payload_configuration_command.timestamp = timestamp;
   communications_payload_configuration_command.comms_payload_ID = comms_payload_ID;
   communications_payload_configuration_command.comms_payload_mode = comms_payload_mode;
   encode_communications_payload_configuration_command(this->node_id, dest_id, &communications_payload_configuration_command, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_payload_bay_mode_command(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t payload_ID,
   uint8_t payload_mode,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   payload_bay_mode_command_t payload_bay_mode_command;
   payload_bay_mode_command.timestamp = timestamp;
   payload_bay_mode_command.payload_ID = payload_ID;
   payload_bay_mode_command.payload_mode = payload_mode;
   encode_payload_bay_mode_command(this->node_id, dest_id, &payload_bay_mode_command, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_payload_bay_status(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t payload_bay_ID,
   uint8_t payload_bay_mode,
   uint8_t payload_status,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   payload_bay_status_t payload_bay_status;
   payload_bay_status.timestamp = timestamp;
   payload_bay_status.payload_bay_ID = payload_bay_ID;
   payload_bay_status.payload_bay_mode = payload_bay_mode;
   payload_bay_status.payload_status = payload_status;
   encode_payload_bay_status(this->node_id, dest_id, &payload_bay_status, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_payload_data_recorder_status(
   uint8_t dest_id,
   float64_t timestamp,
   uint8_t data_recorder_mode,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   payload_data_recorder_status_t payload_data_recorder_status;
   payload_data_recorder_status.timestamp = timestamp;
   payload_data_recorder_status.data_recorder_mode = data_recorder_mode;
   encode_payload_data_recorder_status(this->node_id, dest_id, &payload_data_recorder_status, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_payload_operating_status(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t payload_ID,
   uint8_t payload_mode,
   uint8_t payload_status,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   payload_operating_status_t payload_operating_status;
   payload_operating_status.timestamp = timestamp;
   payload_operating_status.payload_ID = payload_ID;
   payload_operating_status.payload_mode = payload_mode;
   payload_operating_status.payload_status = payload_status;
   encode_payload_operating_status(this->node_id, dest_id, &payload_operating_status, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_communications_payload_status(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t communications_ID,
   uint8_t communications_mode,
   uint8_t communications_status,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   communications_payload_status_t communications_payload_status;
   communications_payload_status.timestamp = timestamp;
   communications_payload_status.communications_ID = communications_ID;
   communications_payload_status.communications_mode = communications_mode;
   communications_payload_status.communications_status = communications_status;
   encode_communications_payload_status(this->node_id, dest_id, &communications_payload_status, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_target_status(
   uint8_t dest_id,
   float64_t timestamp,
   float64_t target_radius,
   float64_t target_angle,
   float64_t target_altitude,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   target_status_t target_status;
   target_status.timestamp = timestamp;
   target_status.target_radius = target_radius;
   target_status.target_angle = target_angle;
   target_status.target_altitude = target_altitude;
   encode_target_status(this->node_id, dest_id, &target_status, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_target_acknowledgement(
   uint8_t dest_id,
   float64_t timestamp,
   uint8_t target_status,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   target_acknowledgement_t target_acknowledgement;
   target_acknowledgement.timestamp = timestamp;
   target_acknowledgement.target_status = target_status;
   encode_target_acknowledgement(this->node_id, dest_id, &target_acknowledgement, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_UAV_location(
   uint8_t dest_id,
   float64_t timestamp,
   float64_t longitude,
   float64_t latitude,
   float64_t altitude,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   UAV_location_t UAV_location;
   UAV_location.timestamp = timestamp;
   UAV_location.longitude = longitude;
   UAV_location.latitude = latitude;
   UAV_location.altitude = altitude;
   encode_UAV_location(this->node_id, dest_id, &UAV_location, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_UAV_speed(
   uint8_t dest_id,
   float64_t timestamp,
   float64_t speed,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   UAV_speed_t UAV_speed;
   UAV_speed.timestamp = timestamp;
   UAV_speed.speed = speed;
   encode_UAV_speed(this->node_id, dest_id, &UAV_speed, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_UAV_heading(
   uint8_t dest_id,
   float64_t timestamp,
   float64_t heading,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   UAV_heading_t UAV_heading;
   UAV_heading.timestamp = timestamp;
   UAV_heading.heading = heading;
   encode_UAV_heading(this->node_id, dest_id, &UAV_heading, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_UAV_battery(
   uint8_t dest_id,
   float64_t timestamp,
   uint32_t battery_percentage,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   UAV_battery_t UAV_battery;
   UAV_battery.timestamp = timestamp;
   UAV_battery.battery_percentage = battery_percentage;
   encode_UAV_battery(this->node_id, dest_id, &UAV_battery, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_UAV_collision_avodiance_status(
   uint8_t dest_id,
   float64_t timestamp,
   uint8_t ca_status,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   UAV_collision_avodiance_status_t UAV_collision_avodiance_status;
   UAV_collision_avodiance_status.timestamp = timestamp;
   UAV_collision_avodiance_status.ca_status = ca_status;
   encode_UAV_collision_avodiance_status(this->node_id, dest_id, &UAV_collision_avodiance_status, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_UAV_mission_status(
   uint8_t dest_id,
   float64_t timestamp,
   uint8_t mission_status,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   UAV_mission_status_t UAV_mission_status;
   UAV_mission_status.timestamp = timestamp;
   UAV_mission_status.mission_status = mission_status;
   encode_UAV_mission_status(this->node_id, dest_id, &UAV_mission_status, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_UAV_collision_avodiance_message(
   uint8_t dest_id,
   float64_t timestamp,
   uint8_t vehicle_ID,
   float64_t velocity,
   float64_t latitude,
   float64_t longtitude,
   float64_t altitude,
   uint8_t priority,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   UAV_collision_avodiance_message_t UAV_collision_avodiance_message;
   UAV_collision_avodiance_message.timestamp = timestamp;
   UAV_collision_avodiance_message.vehicle_ID = vehicle_ID;
   UAV_collision_avodiance_message.velocity = velocity;
   UAV_collision_avodiance_message.latitude = latitude;
   UAV_collision_avodiance_message.longtitude = longtitude;
   UAV_collision_avodiance_message.altitude = altitude;
   UAV_collision_avodiance_message.priority = priority;
   encode_UAV_collision_avodiance_message(this->node_id, dest_id, &UAV_collision_avodiance_message, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_UUV_status(
   uint8_t dest_id,
   uint8_t status,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   UUV_status_t UUV_status;
   UUV_status.status = status;
   encode_UUV_status(this->node_id, dest_id, &UUV_status, &com_msg, key);
   queue.add(&com_msg);
   return;
}

void node::send_ROV_status_message(
   uint8_t dest_id,
   float64_t timestamp,
   uint16_t vehicle_ID,
   uint16_t depth,
   uint16_t roll,
   uint16_t pitch,
   uint16_t heading,
   float32_t battery_percent,
   bool is_emergency)
{
   com_msg_t com_msg;
   com_msg.header.is_emergency = (uint16_t)is_emergency;
   ROV_status_message_t ROV_status_message;
   ROV_status_message.timestamp = timestamp;
   ROV_status_message.vehicle_ID = vehicle_ID;
   ROV_status_message.depth = depth;
   ROV_status_message.roll = roll;
   ROV_status_message.pitch = pitch;
   ROV_status_message.heading = heading;
   ROV_status_message.battery_percent = battery_percent;
   encode_ROV_status_message(this->node_id, dest_id, &ROV_status_message, &com_msg, key);
   queue.add(&com_msg);
   return;
}

