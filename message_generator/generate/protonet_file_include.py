from lower_case_acronym import *

def generate_protonet_file_include(directory, include_extension, src_extension):
    """
    Function will create the protonet header file in .../include/
    File has 2 main parts
        -message callback prototypes
        -class node
            -public functions
            -public send_message
            -public register_on_message
            -private members / functions
            -callback data type functions on_message
    """
    #load header structure and the messages in variables from xml file
    import xml.etree.ElementTree as ET
    tree = ET.parse('message_definition.xml')
    protocol = tree.findall('message')
    header = tree.find('header')
    tab = '   '
    #open file
    f = open(directory + "include/" + 'protonet' + include_extension, 'w')
    # warning
    f.write('/**@file This file was autogenerated. All changes will be undone. */\n\n')
    # include guards
    f.write('#ifndef _PROTONET_H_\n')
    f.write('#define _PROTONET_H_\n\n')
    #include files
    f.write("/*Include files*/ \n")
    f.write('#include <datalink' +include_extension+'>\n')
    f.write('#include <protonet_protocol' +include_extension+'>\n')
    f.write('#include <queue' +include_extension+'>\n')
    f.write('#include <thread' +include_extension+'>\n\n')
    #declare name space
    f.write('namespace protonet\n')
    f.write('{\n')
    #extern/class of node
    f.write(tab + "/*Let compiler know class node exists some where else */ \n")
    f.write(tab + 'class node;\n\n')
    #for each message declare prototype of call back function
    for message in protocol:
        name = message.get('name')
        variable_name = lower_case_acronym(name)
        type_t_name = variable_name + "_t"
        f.write(tab + "/**Global function call back used for message " + name + " must be implemented on platform for use*/ \n")
        f.write(tab+'typedef void* (*'+ variable_name+'_callback)(int8_t, proto_header_t, '+type_t_name+', protonet::node* node_ptr);\n')
    
    #declare class node
    f.write(tab + "/** Class node represents each point of communication. The Node will be able to establish type of communication and send and receive messages. The callbacks must be implemented on the platform*/ \n")
    f.write('\n'+ tab+'class node\n')
    f.write(tab+'{\n')
    #public members
    f.write(tab+'public:\n')
    f.write(tab+tab+'node(uint8_t node_id);\n')
    f.write(tab+tab+'node(uint8_t node_id, int32_t mode);\n')
    f.write(tab+tab+'~node();\n')
    f.write(tab + tab + "/**Public method used to start node connection and messages*/ \n")
    f.write(tab+tab+'void start();\n\n')
    
    f.write(tab + tab + "/** Public method used to add serial communication*/ \n")
    f.write(tab+tab+'void add_serial(int8_t* link_id, uint32_t baud_rate, char device_path[50]);\n')
    f.write(tab + tab + "/** Public method used to add UDP communication*/ \n")
    f.write(tab+tab+'void add_udp(int8_t* link_id, uint16_t port);\n')
    f.write(tab + tab + "/** Public method used to add UDP communication*/ \n")
    f.write(tab+tab+'void add_udp(int8_t* link_id, uint16_t port, char addr[16]);\n\n')
    f.write(tab + tab + "/** Public method used to establish serial communication*/ \n")
    f.write(tab+tab+'void establish_serial(int8_t link_id, uint8_t node_id);\n')
    f.write(tab + tab + "/** Public method used to establish UDP communication*/ \n")
    f.write(tab+tab+'void establish_udp(int8_t link_id, uint8_t node_id, uint16_t port, char addr[16]);\n\n')
    
    f.write(tab+ tab + "/** method returns the number of datalink for this node*/ \n")
    f.write(tab+tab+'uint8_t get_num_datalinks();\n')
    f.write(tab+tab + "/**Public method used to find if datalink is connected*/ \n")
    f.write(tab+tab+'int32_t query_datalink_connected(int8_t link_id);\n')
    f.write(tab+tab + "/**Public method used to find what type of communication the datalink is*/ \n")
    f.write(tab+tab+'datalink_type_t query_datalink_type(int8_t link_id);\n\n')
    
    #declare each send_message
    for message in protocol:
        name = message.get('name')
        variable_name = lower_case_acronym(name)
        type_t_name = variable_name + "_t"        
        f.write(tab + tab + "/**Public definition of the send " + name + " message which will be put into the message queue.*/ \n")
        f.write(tab+tab+'void send_'+ variable_name+'(\n')
        f.write(tab+tab+tab+'uint8_t dest_id,')
        for field in message:
            f.write('\n'+tab+tab+tab+field.get('type')+' '+ field.get('name')+',')
        f.seek(-1, 1)
        f.write(');\n\n')
    #declare register_on_message
    for message in protocol:
        name = message.get('name')
        variable_name = lower_case_acronym(name)
        f.write(tab + tab + "/**Public definition of the register on " + name + " message which will use the message call back.*/ \n")
        f.write(tab+tab+'void register_on_'+ variable_name+'('+variable_name+'_callback callback){on_'+variable_name +' = callback;}\n')
    
    #private members
    f.write('\n'+tab+'private:\n')

    f.write(tab + tab + "/**Private data member hold the node id.*/ \n")
    f.write(tab+tab+'uint8_t node_id;\n\n')

    f.write(tab + tab + "/**Private data member used to keep track of the number of data links associated with this node*/ \n")
    f.write(tab+tab+'int8_t num_datalinks;\n')
    f.write(tab + tab + "/**Private array used to store all the datalink in this node*/ \n")
    f.write(tab+tab+'datalink* datalinks[255];\n')
    f.write(tab + tab + "/**Private data member to keep track of the threads associated with this node*/ \n")
    f.write(tab+tab+'thread_t datalink_threads[255];\n\n')
    
    f.write(tab + tab + "/**Private pointer to the message queue*/ \n")
    f.write(tab+tab+'proto_msg_queue queue;\n')    
    f.write(tab + tab + "/**Private method to handle the message to determine the type of message and its following actions  */ \n")
    f.write(tab+tab+'void handle_proto_msg_t(proto_msg_t* rx_msg, proto_msg_buf_t* rx_buf);\n\n')
    
    f.write(tab + tab + "/**Private data member to hold thread handler*/ \n")
    f.write(tab+tab+'thread_t handler_thread;\n')
    f.write(tab + tab + "/**Private method which is entry point for the event handler that performs callbacks based on incoming messages  */ \n")
    f.write(tab+tab+'void* protonet_handler();\n')
    f.write(tab + tab + "/**Private method Helper functions from C style from C++ entry point with class member linkage*/ \n")
    f.write(tab+tab+'static void* handler_helper(void* context);\n\n')
    
    f.write(tab + tab + "/**Private data member to keep track of upkeep thread data.*/ \n")
    f.write(tab+tab+'thread_t upkeep_thread;\n')
    f.write(tab + tab + "/**Private method for posix and windows compatible sleep method*/ \n")
    f.write(tab+tab+'void* upkeep_handler();\n')
    f.write(tab + tab + "/**Private method returns pointer to upkeep_handler*/ \n")
    f.write(tab+tab+'static void* upkeep_helper(void* context);\n\n')
    
    
    
    f.write(tab + tab + "/**Private methods sets all call backs to null */ \n")
    f.write(tab+tab+'void null_callback_storage();\n\n')

    #declare function as data type callback function name on_message
    for message in protocol:
        name = message.get('name')
        variable_name = lower_case_acronym(name)
        f.write(tab + tab + "/**Private data declares on " + name + " as call back data type used to hold call back*/ \n")
        f.write(tab+tab+variable_name+'_callback on_'+variable_name +';\n')    
    f.write(tab+'};\n')
    f.write('}\n')
    f.write('#endif')
   
    print("Created: " + 'protonet' + include_extension)